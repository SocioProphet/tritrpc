# TritRPC v1 — Full Specification (repo copy)

This file mirrors the **full spec** provided in chat (Status: Draft 1.0). It enumerates
the normative requirements for envelope layout, TritPack243, TLEB3, AEAD, Profiles, Kafka,
Strict-Initial (PoE), and the reference hypergraph service.

For convenience, the **reference implementation** in `reference/tritrpc_v1.py` adheres to:
- Path-A (Avro Binary Encoding) for payloads,
- AEAD lane (XChaCha20-Poly1305),
- HELLO/CHOOSE negotiation examples,
- AUX structures: Trace, Sig (placeholder), PoE (toy subset).

**Port note (Go/Rust):** only **XChaCha20-Poly1305** is implemented. The BLAKE2b MAC fallback
described in early drafts remains **reference-only and non-normative** for this repository’s
ports and fixtures. Rolling nonces are not implemented in Go/Rust; fixtures rely on explicit
per-frame nonces in `*.nonces`.
The AUX field is treated as an opaque byte slice in Go/Rust; fixtures currently omit AUX.

### AEAD AAD definition (normative for ports + fixtures)

When AEAD is enabled, the tag is computed using **empty plaintext** with **AAD equal to the
exact envelope bytes up to (but not including) the length prefix of the final tag field**.
This means the AAD covers all prior fields, including payload and AUX if present.

See `fixtures/` for **canonical hex vectors** generated by this reference.

## Canonicalization & Hashing (JSON / Receipts)

Any JSON that participates in hashing, signing, or receipt verification is **byte-canonicalized**
using **RFC 8785 (JSON Canonicalization Scheme, JCS)**. Implementations MUST NOT hash or sign
implementation-defined serializer output.

Normative steps (MUST):

1. **Parse** input as JSON per **RFC 8259** (no JSON5 extensions).
2. **Canonicalize** per **RFC 8785 (JCS)**:
   - UTF-8 output.
   - Deterministic object member ordering per JCS.
   - No insignificant whitespace.
   - String escaping per JCS/JSON rules.
   - Numbers rendered per JCS (shortest round-trippable decimal form).
3. **Reject non-finite numbers** (`NaN`, `+Inf`, `-Inf`).
4. **Hash/sign input** = **UTF-8 bytes** of the JCS canonical JSON produced in step (2).
5. **Compute content hash** using **BLAKE3** over those canonical bytes.

Receipts are considered replay-grade only when their hashes are computed via the JCS canonical
bytes described above. Implementations MUST pass the published canonicalization + BLAKE3 test
vectors before they are considered compliant.

Golden vectors (canonical JSON + expected BLAKE3) are maintained in
`fixtures/jcs_blake3_vectors.json`.
